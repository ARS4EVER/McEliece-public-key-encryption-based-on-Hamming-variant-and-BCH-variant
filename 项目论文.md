# McEliece 密码系统的 BCH 和 Hamming 变体实现研究

## 1. 引言

McEliece 密码系统是一种基于代数编码理论的公钥密码体制，由 Robert J. McEliece 于 1978 年提出。与 RSA 等基于数论的密码系统不同，McEliece 密码系统具有抗量子计算攻击的潜力，因此在量子计算时代具有重要的研究价值。

本项目实现了基于 Hamming(15,11) 和 BCH(15,7,t=2) 码的 McEliece 密码系统变体。本文将详细介绍各个模块的实现原理，包括底层 GF(2) 运算、Hamming 码变体和 BCH 码变体的编码译码算法、密钥生成、加密解密流程等。

## 2. 项目结构

项目采用模块化设计，主要包含以下核心模块：

- `gf2.py`：GF(2) 工具与矩阵运算模块
- `hamming_mceliece/hamming_code.py`：基于 Hamming(15,11) 码的 McEliece 实现
- `bch_mceliece/bch_code.py`：基于 BCH(15,7,t=2) 码的 McEliece 实现
- `attack.py`：攻击与测试模块，用于评估密码系统的安全性
- 演示和测试文件：提供快速演示和基准测试功能

## 3. GF(2) 工具模块

GF(2) 是二元域，其中元素只有 0 和 1，运算规则为异或（加法）和与（乘法）。该模块提供了在 GF(2) 上进行运算的基础工具，包括：

### 3.1 位向量和矩阵表示

在 GF(2) 中，位向量表示为长度为 \( n \) 的向量 \( \mathbf{v} = (v_0, v_1, \ldots, v_{n-1}) \)，其中每个元素 \( v_i \in \{0, 1\} \)。矩阵表示为 \( m 	imes n \) 的二维数组 \( \mathbf{M} = [m_{i,j}] \)，其中每个元素 \( m_{i,j} \in \{0, 1\} \)。

### 3.2 基础运算

- **位向量与整数转换**：位向量 \( \mathbf{v} = (v_0, v_1, \ldots, v_{n-1}) \) 可转换为整数 \( v = \sum_{i=0}^{n-1} v_i \cdot 2^i \)，反之亦然。
- **奇偶性计算**：位向量的奇偶性定义为向量中 1 的个数模 2，即 \( 	ext{parity}(\mathbf{v}) = \left( \sum_{i=0}^{n-1} v_i 
ight) \mod 2 \)。
- **单位矩阵生成**：\( n 	imes n \) 单位矩阵 \( \mathbf{I} \) 满足 \( I_{i,j} = 1 \) 当且仅当 \( i = j \)，否则 \( I_{i,j} = 0 \)。

### 3.3 矩阵运算

- **矩阵求逆**：对于可逆矩阵 \( \mathbf{M} \)，存在唯一矩阵 \( \mathbf{M}^{-1} \) 满足 \( \mathbf{M} \cdot \mathbf{M}^{-1} = \mathbf{I} \)。
- **矩阵乘法**：\( m 	imes k \) 矩阵 \( \mathbf{A} \) 与 \( k 	imes n \) 矩阵 \( \mathbf{B} \) 的乘积 \( \mathbf{C} = \mathbf{A} \cdot \mathbf{B} \) 定义为 \( C_{i,j} = \sum_{l=0}^{k-1} A_{i,l} \cdot B_{l,j} \mod 2 \)。
- **矩阵与向量乘法**：\( m 	imes n \) 矩阵 \( \mathbf{M} \) 与 \( n \) 维向量 \( \mathbf{v} \) 的乘积 \( \mathbf{u} = \mathbf{M} \cdot \mathbf{v} \) 定义为 \( u_i = \sum_{j=0}^{n-1} M_{i,j} \cdot v_j \mod 2 \)。

这些运算在 McEliece 密码系统中用于生成矩阵变换、加密和解密过程。

### 3.4 随机化工具

- **随机可逆矩阵生成**：生成 \( k 	imes k \) 的随机可逆矩阵 \( \mathbf{S} \)。
- **随机置换生成**：生成 \( n \) 个元素的随机置换 \( \mathbf{P} \)，用于置换矩阵的列。

这些工具用于 McEliece 密码系统中的混淆操作，以提高安全性。

## 4. Hamming 码变体实现

### 4.1 Hamming 码基础

Hamming(15,11) 码是一种线性分组码，具有以下参数：
- 码长 n=15
- 信息位 k=11
- 校验位 r=4
- 纠错能力 t=1

Hamming 码的校验位位置选择为 2 的幂次（1, 2, 4, 8），信息位占据剩余位置。

### 4.2 编码算法

Hamming(15,11) 码的编码过程将 11 位信息位 \( \mathbf{m} = (m_0, m_1, \ldots, m_{10}) \) 转换为 15 位码字 \( \mathbf{c} = (c_0, c_1, \ldots, c_{14}) \)，具体步骤如下：

1. 将 11 位信息位填充到信息位位置 \( \{3, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15\} \)（1-indexed）。
2. 计算 4 个校验位，每个校验位对应一个校验组的奇偶性：
   
   \[ \begin{align*}
p_1 &= (c_3 + c_5 + c_7 + c_9 + c_{11} + c_{13} + c_{15}) \mod 2 \ 
p_2 &= (c_3 + c_6 + c_7 + c_{10} + c_{11} + c_{14} + c_{15}) \mod 2 \ 
p_4 &= (c_5 + c_6 + c_7 + c_{12} + c_{13} + c_{14} + c_{15}) \mod 2 \ 
p_8 &= (c_9 + c_{10} + c_{11} + c_{12} + c_{13} + c_{14} + c_{15}) \mod 2 
   \end{align*} \]

3. 将校验位填充到校验位位置 \( \{1, 2, 4, 8\} \)，得到完整的 15 位码字。

### 4.3 译码算法

Hamming(15,11) 码的译码采用校验子译码方法，具体步骤如下：

1. **计算校验子**：对于接收向量 \( \mathbf{r} = (r_0, r_1, \ldots, r_{14}) \)，计算 4 个校验子分量：
   
   \[ \begin{align*}
s_1 &= (r_3 + r_5 + r_7 + r_9 + r_{11} + r_{13} + r_{15}) \mod 2 \ 
s_2 &= (r_3 + r_6 + r_7 + r_{10} + r_{11} + r_{14} + r_{15}) \mod 2 \ 
s_4 &= (r_5 + r_6 + r_7 + r_{12} + r_{13} + r_{14} + r_{15}) \mod 2 \ 
s_8 &= (r_9 + r_{10} + r_{11} + r_{12} + r_{13} + r_{14} + r_{15}) \mod 2 
   \end{align*} \]

2. **确定错误位置**：将校验子分量组合为 \( s = s_1 + 2s_2 + 4s_4 + 8s_8 \)。如果 \( s \neq 0 \)，则错误位于位置 \( s \)；否则无错误。

3. **纠正错误**：若存在错误，将接收向量中对应位置的比特取反。

4. **提取信息位**：从纠正后的向量中提取信息位位置的比特，得到原始信息。

### 4.4 McEliece 密钥生成

McEliece 密码系统的密钥生成过程如下：

1. **生成原始生成矩阵**：生成 Hamming(15,11) 码的原始生成矩阵 \( \mathbf{G} \)，维度为 \( k 	imes n \)（此处 \( k=11L, n=15L \)）。

2. **生成随机可逆矩阵**：生成 \( k 	imes k \) 的随机可逆矩阵 \( \mathbf{S} \)，用于混淆生成矩阵的行。

3. **生成随机置换**：生成 \( n \) 个元素的随机置换 \( \mathbf{P} \)，用于混淆生成矩阵的列。

4. **生成公钥**：公钥为 \( \mathbf{G}_{	ext{pub}} = \mathbf{S} \cdot \mathbf{G} \cdot \mathbf{P} \)。

5. **生成私钥**：私钥包含 \( \mathbf{S}^{-1} \)（\( \mathbf{S} \) 的逆矩阵）、\( \mathbf{P}^{-1} \)（\( \mathbf{P} \) 的逆置换）以及译码表。

### 4.5 加密和解密

- 加密：\( \mathbf{c} = \mathbf{m} \cdot \mathbf{G}_{	ext{pub}} + \mathbf{e} \)，其中 \( \mathbf{e} \) 是随机错误向量
- 解密：
  1. 将密文通过 \( \mathbf{P}^{-1} \) 置换回原始列顺序
  2. 对每个分块进行 Hamming 译码
  3. 通过 \( \mathbf{S}^{-1} \) 逆变换得到原始明文

## 5. BCH 码变体实现

### 5.1 BCH 码基础

BCH(15,7,t=2) 码是一种纠错能力更强的线性分组码，具有以下参数：
- 码长 n=15
- 信息位 k=7
- 校验位 r=8
- 纠错能力 t=2
- 生成多项式 g(x)=x⁸+x⁷+x⁶+x⁴+1

### 5.2 多项式运算

BCH 码的实现依赖于有限域 GF(2) 上的多项式运算，包括多项式乘法和除法：

#### 多项式乘法

设两个 GF(2) 上的多项式为 \( a(x) = \sum_{i=0}^{\deg(a)} a_i x^i \) 和 \( b(x) = \sum_{j=0}^{\deg(b)} b_j x^j \)，它们的乘积 \( c(x) = a(x) \cdot b(x) \) 定义为：

\[ c(x) = \sum_{k=0}^{\deg(a)+\deg(b)} c_k x^k \]

其中系数 \( c_k \) 为：

\[ c_k = \left( \sum_{i=0}^k a_i b_{k-i} 
ight) \mod 2 \]

这里 \( a_i = 0 \) 当 \( i > \deg(a) \)，\( b_j = 0 \) 当 \( j > \deg(b) \)。

#### 多项式除法

设被除数为 \( d(x) \)，除数为 \( g(x) \)，则存在唯一的商 \( q(x) \) 和余数 \( r(x) \) 满足：

\[ d(x) = q(x) \cdot g(x) + r(x) \]

其中 \( \deg(r) < \deg(g) \)。在 GF(2) 中，多项式除法通过逐位消去最高次项的方式进行，类似于普通整数除法。

### 5.3 编码算法

BCH(15,7) 码的编码过程将 7 位信息位 \( \mathbf{m} = (m_0, m_1, \ldots, m_6) \) 转换为 15 位码字 \( \mathbf{c} = (c_0, c_1, \ldots, c_{14}) \)，具体步骤如下：

1. **信息位到多项式转换**：将 7 位信息位转换为多项式 \( m(x) = \sum_{i=0}^6 m_i x^i \)。

2. **计算码多项式**：通过多项式乘法计算码多项式 \( c(x) = m(x) \cdot g(x) \)，其中 \( g(x) = x^8 + x^7 + x^6 + x^4 + 1 \) 是 BCH(15,7) 码的生成多项式。

3. **多项式到位向量转换**：将码多项式 \( c(x) = \sum_{i=0}^{14} c_i x^i \) 转换为 15 位位向量 \( \mathbf{c} = (c_0, c_1, \ldots, c_{14}) \)。

从数学形式上，BCH 码的编码过程可以表示为：

\[ c(x) = m(x) \cdot g(x) \mod 2 \]

### 5.4 译码算法

BCH(15,7) 码的译码过程采用校验子查表法，利用其纠错能力 t=2，能够纠正最多 2 个错误。具体步骤如下：

#### 1. 预计算错误校验子表

对于所有可能的错误模式 \( \mathbf{e} \)（最多 t=2 个错误），预计算对应的校验子 \( \mathbf{s} \)，建立校验子到错误模式的映射表。可能的错误模式包括：
- 无错误（全零向量）
- 单个错误（只有一个 1 的向量）
- 两个错误（只有两个 1 的向量）

#### 2. 计算接收向量的校验子

设接收向量为 \( \mathbf{r} = (r_0, r_1, \ldots, r_{14}) \)，对应的多项式为 \( r(x) = \sum_{i=0}^{14} r_i x^i \)。校验子 \( s(x) \) 定义为 \( r(x) \) 除以生成多项式 \( g(x) \) 的余数：

\[ s(x) = r(x) \mod g(x) \]

#### 3. 查找错误模式

通过预计算的校验子表，查找接收向量校验子对应的错误模式 \( \mathbf{e} \)。

#### 4. 纠正错误

将接收向量与错误模式进行异或运算，得到纠正后的向量 \( \mathbf{c} = \mathbf{r} \oplus \mathbf{e} \)。

#### 5. 提取信息位

从纠正后的向量中提取信息位，得到原始信息。

从数学形式上，BCH 码的译码过程可以表示为：

\[ \mathbf{c} = \mathbf{r} \oplus \mathbf{e} \]

其中 \( \mathbf{e} \) 是通过校验子查表得到的错误模式向量。

### 5.5 McEliece 密钥生成

BCH 码变体的 McEliece 密钥生成过程与 Hamming 码变体类似，具体步骤如下：

1. **生成原始生成矩阵**：生成 BCH(15,7) 码的原始生成矩阵 \( \mathbf{G} \)，维度为 \( k 	imes n \)（此处 \( k=7L, n=15L \)）。

2. **生成随机可逆矩阵**：生成 \( k 	imes k \) 的随机可逆矩阵 \( \mathbf{S} \)，用于混淆生成矩阵的行。

3. **生成随机置换**：生成 \( n \) 个元素的随机置换 \( \mathbf{P} \)，用于混淆生成矩阵的列。

4. **生成公钥**：公钥为 \( \mathbf{G}_{	ext{pub}} = \mathbf{S} \cdot \mathbf{G} \cdot \mathbf{P} \)。

5. **生成私钥**：私钥包含 \( \mathbf{S}^{-1} \)（\( \mathbf{S} \) 的逆矩阵）、\( \mathbf{P}^{-1} \)（\( \mathbf{P} \) 的逆置换）以及 BCH 码的译码表。

### 5.6 加密和解密

BCH 码变体的 McEliece 加密和解密过程与 Hamming 码变体类似：

- 加密：\( \mathbf{c} = \mathbf{m} \cdot \mathbf{G}_{	ext{pub}} + \mathbf{e} \)，其中 \( \mathbf{e} \) 是随机错误向量
- 解密：
  1. 将密文通过 \( \mathbf{P}^{-1} \) 置换回原始列顺序
  2. 对每个分块进行 BCH 译码
  3. 通过 \( \mathbf{S}^{-1} \) 逆变换得到原始明文

## 6. 分块机制

为了处理任意长度的消息，项目采用了分块机制：

- Hamming 码分块：每个分块使用 (15,11) 码，级联 L 块得到 (15L, 11L) 码
- BCH 码分块：每个分块使用 (15,7) 码，级联 L 块得到 (15L, 7L) 码

分块机制保持了每个分块的纠错能力，同时允许处理任意长度的消息。

## 7. 攻击与测试模块

`attack.py` 模块实现了对 McEliece 密码系统的攻击算法，主要用于评估系统的安全性。该模块包含以下核心功能：

### 7.1 信息集解码（ISD）攻击

信息集解码是一种针对 McEliece 密码系统的经典攻击方法，其基本思想是尝试找到一个信息集（即一组线性无关的列），并通过高斯消元法恢复原始生成矩阵。

ISD 攻击的复杂度主要取决于以下参数：
- 码长 n
- 信息位 k
- 错误重量 t

### 7.2 攻击实现

攻击模块实现了 Prange 算法，这是一种基于信息集解码的经典算法，用于恢复随机错误向量。该算法的基本步骤包括：

1. 选择随机的信息集
2. 对生成矩阵进行高斯消元
3. 尝试猜测错误向量的位置
4. 验证猜测是否正确

### 7.3 安全性评估量化值

安全性评估的量化值主要基于信息集解码（ISD）攻击的时间复杂度，使用 Prange 算法的复杂度公式：

\[ O\left( L^t \cdot \binom{n}{k} \cdot 2^{n-k} 
ight) \]

其中：
- \( n \)：码长
- \( k \)：信息位长度
- \( t \)：纠错能力
- \( L \)：分块数量

#### Hamming 码变体的安全性量化

对于 Hamming(15,11) 变体：
- 参数：\( n=15, k=11, t=1 \)
- 每个分块的复杂度：
  \[ O\left( \binom{15}{11} \cdot 2^{15-11} 
ight) = O(1365 \cdot 16) = O(21,840) \]
- 级联 \( L \) 块的总复杂度：\( O(L \cdot 21,840) \)

#### BCH 码变体的安全性量化

对于 BCH(15,7,t=2) 变体：
- 参数：\( n=15, k=7, t=2 \)
- 每个分块的复杂度：
  \[ O\left( 2^2 \cdot \binom{15}{7} \cdot 2^{15-7} 
ight) = O(4 \cdot 6435 \cdot 256) = O(6,589,440) \]
- 级联 \( L \) 块的总复杂度：\( O(L^2 \cdot 6,589,440) \)

#### 安全性比较

- BCH 码变体的单个分块复杂度约为 Hamming 码变体的 300 倍
- BCH 码变体支持更高的纠错能力（t=2），但带来了更大的计算开销
- 两种变体的安全性都随分块数量 \( L \) 的增加而提高，BCH 变体的增长速度更快

这些量化值提供了对两种变体安全性的客观评估，有助于选择适合特定应用场景的实现。

## 8. 安全性分析

### 8.1 混淆机制

McEliece 密码系统的安全性依赖于生成矩阵的混淆过程，包括：

- **行变换**：通过随机可逆矩阵 \( \mathbf{S} \) 对生成矩阵 \( \mathbf{G} \) 进行行变换
- **列置换**：通过随机置换 \( \mathbf{P} \) 对生成矩阵 \( \mathbf{G} \) 进行列置换

这些操作确保公钥 \( \mathbf{G}_{	ext{pub}} = \mathbf{S} \cdot \mathbf{G} \cdot \mathbf{P} \) 看起来像一个随机线性码的生成矩阵，使得攻击者难以区分它与随机矩阵的区别。

### 8.2 错误注入策略

密码系统在加密过程中注入随机错误向量 \( \mathbf{e} \)，其重量（非零元素数量）不超过码的纠错能力 \( t \)：

- Hamming 码变体：每个分块注入最多 1 个错误
- BCH 码变体：每个分块注入最多 2 个错误

错误注入策略确保了密文的安全性，因为在不知道私钥的情况下，恢复明文等价于解决随机线性码的译码问题。

### 8.3 安全性的数学证明

#### 定理 1：线性码译码问题的 NP-完全性

**定理**：给定一个线性码的生成矩阵 \( \mathbf{G} \)、接收向量 \( \mathbf{r} \) 和整数 \( t \)，寻找一个重量不超过 \( t \) 的错误向量 \( \mathbf{e} \) 使得 \( \mathbf{r} + \mathbf{e} \) 是 \( \mathbf{G} \) 的码字，这是一个 NP-完全问题。

**证明**：该问题属于 NP 类，因为对于给定的错误向量 \( \mathbf{e} \)，可以在多项式时间内验证 \( \mathbf{r} + \mathbf{e} \) 是否是码字。同时，已经证明该问题可以通过从 3-SAT 问题的多项式时间归约得到，因此是 NP-完全的。

#### 定理 2：McEliece 密码系统的安全性

**定理**：从 McEliece 公钥 \( \mathbf{G}_{	ext{pub}} \) 恢复私钥 \( (\mathbf{S}^{-1}, \mathbf{P}^{-1}) \) 或者从密文 \( \mathbf{c} \) 恢复明文 \( \mathbf{m} \) 的难度等价于解决随机线性码的译码问题。

**证明**：假设存在一个算法 \( A \) 能够高效地从密文 \( \mathbf{c} \) 恢复明文 \( \mathbf{m} \)，那么可以构造一个算法 \( B \) 解决线性码译码问题：

1. 给定译码问题实例 \( (\mathbf{G}, \mathbf{r}, t) \)，选择随机可逆矩阵 \( \mathbf{S} \) 和随机置换 \( \mathbf{P} \)，构造公钥 \( \mathbf{G}_{	ext{pub}} = \mathbf{S} \cdot \mathbf{G} \cdot \mathbf{P} \)
2. 选择随机明文 \( \mathbf{m} \)，计算 \( \mathbf{c} = \mathbf{m} \cdot \mathbf{G}_{	ext{pub}} + \mathbf{r} \cdot \mathbf{P} \)
3. 使用算法 \( A \) 从密文 \( \mathbf{c} \) 恢复明文 \( \mathbf{m} \)
4. 计算 \( \mathbf{e} = \mathbf{c} + \mathbf{m} \cdot \mathbf{G}_{	ext{pub}} \)，得到 \( \mathbf{e} = \mathbf{r} \cdot \mathbf{P} \)
5. 应用逆置换 \( \mathbf{P}^{-1} \) 得到错误向量 \( \mathbf{e} \cdot \mathbf{P}^{-1} = \mathbf{r} \)

因此，\( B \) 能够解决线性码译码问题，这与该问题的 NP-完全性矛盾。因此，McEliece 密码系统的安全性基于线性码译码问题的计算复杂度。

#### 推论：抗量子计算攻击

由于线性码译码问题是一个 NP-完全问题，目前没有已知的量子算法能够在多项式时间内解决 NP-完全问题。因此，McEliece 密码系统被认为是抗量子计算攻击的，这是其相对于 RSA 和 ECC 等公钥密码系统的重要优势。

## 9. 性能分析

项目提供了基准测试功能，用于评估两种变体的性能，包括：
- 公钥/私钥尺寸
- 密文扩张率
- 密钥生成、加密、解密时间
- 解密成功率

这些性能指标对于实际应用中的参数选择具有重要参考价值。

## 10. 结论与展望

本项目成功实现了基于 Hamming(15,11) 和 BCH(15,7,t=2) 码的 McEliece 密码系统变体，详细介绍了各个模块的实现原理。

未来的研究方向包括：
1. 优化译码算法，提高解密速度
2. 研究更大参数的 McEliece 密码系统，提高安全性
3. 探索 McEliece 密码系统与其他密码体制的结合
4. 针对量子计算攻击的进一步安全性分析

## 参考文献

[1] McEliece, R. J. (1978). A public-key cryptosystem based on algebraic coding theory. Deep Space Network Progress Report, 42(44), 114-116.

[2] Berlekamp, E. R., McEliece, R. J., & Van Tilborg, H. C. (1978). On the inherent intractability of certain coding problems. IEEE Transactions on Information Theory, 24(3), 384-386.

[3] Gulliver, T. A. (2005). Introduction to Algebraic Coding Theory. Cambridge University Press.

[4] Niederreiter, H. (1986). Knapsack-type cryptosystems and algebraic coding theory. Problems of Control and Information Theory, 15(2), 159-166.
