import random
import sys
import os
import time
from typing import List, Tuple

# 将当前目录加入路径，以便导入 code 包
sys.path.append(os.path.dirname(__file__))

from code.gf2 import (
    mat_inv,
    mat_vec_mul,
    weight,
    Matrix,
    BitVector
)
# 引入 Hamming 方案用于生成测试数据
from code.hamming_mceliece.hamming_code import HammingMcEliece

def get_submatrix(G: Matrix, columns: List[int]) -> Matrix:
    """
    从矩阵 G 中提取指定的列构成子矩阵
    """
    return [[row[c] for c in columns] for row in G]

def get_subvector(vec: BitVector, columns: List[int]) -> BitVector:
    """
    从向量 vec 中提取指定的列
    """
    return [vec[c] for c in columns]

def generate_error_vectors(n: int, t: int) -> List[BitVector]:
    """
    生成所有重量为 t 的错误向量
    """
    result = []
    
    def backtrack(pos: int, remaining: int, current: List[int]):
        if remaining == 0:
            # 生成完整的错误向量
            vec = [0] * n
            for idx in current:
                vec[idx] = 1
            result.append(vec)
            return
        
        if pos + remaining > n:
            return
        
        # 选择当前位置
        current.append(pos)
        backtrack(pos + 1, remaining - 1, current)
        current.pop()
        
        # 不选择当前位置
        backtrack(pos + 1, remaining, current)
    
    backtrack(0, t, [])
    return result

def isd_mmt(G_pub: Matrix, c: BitVector, t: int, max_iter: int = 100000) -> Tuple[BitVector, bool, int]:
    """
    使用 MMT 算法进行 ISD 攻击
    
    参数:
        G_pub: 公钥矩阵 (k x n)
        c: 密文向量 (长度 n)
        t: 目标错误重量 (Error weight)
        max_iter: 最大尝试次数
        
    返回:
        (破解出的明文 m, 是否成功, 尝试次数)
    """
    k = len(G_pub)      # 行数即为 k
    n = len(G_pub[0])   # 列数即为 n
    
    print(f"[*] 开始 ISD MMT 攻击...")
    print(f"    参数: n={n}, k={k}, t={t}")
    print(f"    最大尝试次数: {max_iter}")

    for attempt in range(1, max_iter + 1):
        # 1. 随机选取 k 个列索引 (信息集 I)
        I = random.sample(range(n), k)
        J = [j for j in range(n) if j not in I]
        m = len(J)  # J的长度为n-k
        
        # 2. 提取子矩阵 G_I 和 G_J
        G_I = get_submatrix(G_pub, I)
        G_J = get_submatrix(G_pub, J)
        
        try:
            # 3. 计算 G_I 的逆矩阵
            if attempt % 100 == 0:
                print(f"    尝试次数: {attempt}, 处理信息集: {I[:5]}...", end='\r')
            G_I_inv = mat_inv(G_I)
            
            # 4. 计算变换后的矩阵 G_J' = G_I^{-1} * G_J
            # G_I_inv 是 k x k 矩阵，G_J 是 k x (n-k) 矩阵
            # 结果 G_J_prime 应该是 k x (n-k) 矩阵
            G_J_prime = []
            for i in range(k):
                row = [0] * m  # m = n - k
                for j in range(m):
                    dot = 0
                    for l in range(k):
                        dot ^= G_I_inv[i][l] & G_J[l][j]
                    row[j] = dot
                G_J_prime.append(row)
            
            # 5. 划分密文向量 c
            c_I = get_subvector(c, I)
            c_J = get_subvector(c, J)
            
            # 6. 计算 c' = G_I^{-1} * c_I
            c_prime = [0] * k
            for i in range(k):
                dot = 0
                for j in range(k):
                    dot ^= G_I_inv[i][j] & c_I[j]
                c_prime[i] = dot
            
            # 7. MMT 算法的核心：将错误向量拆分
            # 将 I 划分为 A 和 B，J 划分为 C 和 D
            # 这里简化实现，将 A 设为前 k//2 个位置，B 设为后 k - k//2 个位置
            split_k = k // 2
            A_indices = I[:split_k]
            B_indices = I[split_k:]
            
            # 将 J 划分为 C 和 D，对应 G_J_prime 的划分
            split_m = m // 2
            C_indices = J[:split_m]
            D_indices = J[split_m:]
            
            G_A_prime = get_submatrix(G_J_prime, list(range(split_m)))
            G_B_prime = get_submatrix(G_J_prime, list(range(split_m, m)))
            
            c_A = get_subvector(c_J, list(range(split_m)))
            c_B = get_subvector(c_J, list(range(split_m, m)))
            
            # 8. 计算 c'_A = c_A + c_prime * G_A_prime
            c_prime_A = [0] * split_m
            for i in range(split_m):
                dot = 0
                for j in range(k):
                    dot ^= c_prime[j] & G_A_prime[j][i]
                c_prime_A[i] = c_A[i] ^ dot
            
            # 计算 c'_B = c_B + c_prime * G_B_prime
            c_prime_B = [0] * (m - split_m)
            for i in range(m - split_m):
                dot = 0
                for j in range(k):
                    dot ^= c_prime[j] & G_B_prime[j][i]
                c_prime_B[i] = c_B[i] ^ dot
            
            # 9. 确定各部分错误向量的重量分配
            # 这里简化实现，尝试多种重量分配
            for t_A in range(0, min(t, split_k) + 1):
                for t_B in range(0, min(t - t_A, k - split_k) + 1):
                    t_C = 0  # 假设 C 部分错误重量为 0
                    t_D = t - t_A - t_B  # D 部分错误重量
                    
                    if t_D < 0 or t_D > (m - split_m):
                        continue
                    
                    # 10. 生成所有可能的 e_A
                    e_A_candidates = generate_error_vectors(split_k, t_A)
                    
                    # 11. 生成列表 A: (e_A * G_A_prime + c'_A, e_A)
                    list_A = []
                    for e_A in e_A_candidates:
                        # 计算 e_A * G_A_prime
                        product = [0] * split_m
                        for i in range(split_m):
                            dot = 0
                            for j in range(split_k):
                                dot ^= e_A[j] & G_A_prime[j][i]
                            product[i] = dot
                        
                        # 计算 e_A * G_A_prime + c'_A
                        key = [a ^ b for a, b in zip(product, c_prime_A)]
                        list_A.append((tuple(key), e_A))
                    
                    # 12. 生成所有可能的 e_B
                    e_B_candidates = generate_error_vectors(k - split_k, t_B)
                    
                    # 13. 生成列表 B: (e_B * G_B_prime + c'_B, e_B)
                    list_B = []
                    for e_B in e_B_candidates:
                        # 计算 e_B * G_B_prime
                        product = [0] * (m - split_m)
                        for i in range(m - split_m):
                            dot = 0
                            for j in range(k - split_k):
                                dot ^= e_B[j] & G_B_prime[j][i]
                            product[i] = dot
                        
                        # 计算 e_B * G_B_prime + c'_B
                        key = [a ^ b for a, b in zip(product, c_prime_B)]
                        list_B.append((tuple(key), e_B))
                    
                    # 14. 查找碰撞
                    # 将列表 A 转换为字典以便快速查找
                    dict_A = {key: e_A for key, e_A in list_A}
                    
                    for key_B, e_B in list_B:
                        if key_B in dict_A:
                            e_A = dict_A[key_B]
                            
                            # 15. 构建完整的 e_I
                            e_I = e_A + e_B
                            
                            # 16. 计算 e_J
                            # e_J = e_I * G_J_prime + (c_J + c_prime * G_J_prime)
                            e_J = [0] * m
                            for i in range(m):
                                dot = 0
                                for j in range(k):
                                    dot ^= e_I[j] & G_J_prime[j][i]
                                if i < split_m:
                                    e_J[i] = dot ^ c_J[i] ^ c_prime_A[i]
                                else:
                                    e_J[i] = dot ^ c_J[i] ^ c_prime_B[i - split_m]
                            
                            # 17. 验证 e_J 的重量是否为 t_C + t_D
                            if weight(e_J) != t_C + t_D:
                                continue
                            
                            # 18. 构建完整的错误向量 e
                            e = [0] * n
                            for i, idx in enumerate(I):
                                e[idx] = e_I[i]
                            for i, idx in enumerate(J):
                                e[idx] = e_J[i]
                            
                            # 19. 验证错误向量的总重量
                            if weight(e) != t:
                                continue
                            
                            # 20. 计算候选明文 m = (c - e) * G_I^{-1}
                            c_minus_e = [a ^ b for a, b in zip(c, e)]
                            c_minus_e_I = get_subvector(c_minus_e, I)
                            
                            m_candidate = [0] * k
                            for i in range(k):
                                dot = 0
                                for j in range(k):
                                    dot ^= c_minus_e_I[j] & G_I_inv[i][j]
                                m_candidate[i] = dot
                            
                            # 21. 最终验证
                            c_recalc = mat_vec_mul(m_candidate, G_pub)
                            e_candidate = [c[i] ^ c_recalc[i] for i in range(n)]
                            
                            if weight(e_candidate) == t:
                                print(f"[+] 攻击成功! 在第 {attempt} 次尝试找到解。")
                                return m_candidate, True, attempt
            
        except ValueError:
            # 矩阵不可逆，跳过本次尝试
            continue
            
        # 可选: 每 1000 次打印进度
        if attempt % 1000 == 0:
            print(f"    已尝试 {attempt} 次...", end='\r')

    print(f"[-] 攻击失败，达到最大尝试次数 ({max_iter})。")
    return [], False, max_iter

def main():
    # --- 1. 准备环境 ---
    # 使用较小的参数以便快速演示
    # Hamming(15,11), L=3 -> n=45, k=33, t=3
    # 搜索空间约为 log2(C(45,3)/C(12,3)) ≈ 14190 / 220 ≈ 64 (很小，容易破解)
    # print("=== 生成测试数据 (Hamming L=3) ===")
    # scheme = HammingMcEliece(L=4, errors_per_block=1)
    # pub, priv = scheme.keygen()
    
    # # 随机生成明文
    # expected_msg = [random.randint(0, 1) for _ in range(pub.k)]
    
    # # 加密
    # ciphertext = scheme.encrypt(expected_msg, pub)
    # t = pub.errors_per_block * pub.L  # 总错误量
    # print(pub.G_pub)
    # print(ciphertext)
    # print(expected_msg)
    G_pub=[[0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1], [0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0], [0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0], [1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1], [1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1], [1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1], [1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0], [0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0], [1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1], [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1], [1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1], [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1], [1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0], [1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0], [0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1], [0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0], [1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0], [0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1], [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1], [0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0], [0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1], [0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1], [0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1], [1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1], [0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1], [1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0], [0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0], [1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0], [1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0], [1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], [0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0], [1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1], [1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1], [0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1]]
    ciphertext=[1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0]
    expected_msg=[1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0]
    # --- 2. 执行攻击 ---
    start_time = time.time()
    
    # 注意: 我们只传入公钥、密文和错误数量 t
    # 攻击者完全不知道私钥 priv
    recovered_msg, success, attempts = isd_mmt(G_pub, ciphertext, t=4)
    
    end_time = time.time()
    duration = end_time - start_time
    
    # --- 3. 结果验证 ---
    if success:
        if recovered_msg == expected_msg:
            print(f"\n[v] 验证通过: 破解出的明文与原始明文一致!")
            print(f"    耗时: {duration:.4f} 秒")
            print(f"    速度: {attempts / duration:.2f} iter/s")
        else:
            print(f"\n[x] 验证失败: 找到了满足重量限制的解，但与原明文不符 (可能存在多解)。")
    else:
        print("\n[!] 请尝试增加 max_iter 或检查参数。")

if __name__ == "__main__":
    main()